
#ifndef __RENDER_KERNEL_CODE
#define __RENDER_KERNEL_CODE

std::string renderKernelCode =
"\n"
"#define PI 3.1415926536\n"
"\n"
"/*\n"
"  Reflects the given vector I across the given normal N.\n"
"  @param I - The incoming vector.\n"
"  @param N - The normal.\n"
"  @return The outgoing reflected vector.\n"
"*/\n"
"float3 reflect(float3 I, float3 N) { return I - 2.0f*dot(N,I)*N; }\n"
"\n"
"/*\n"
"  Represents a ray.\n"
"*/\n"
"typedef struct ray {\n"
"   /*\n"
"    The direction of the ray.\n"
"   */\n"
"   float3 dir;\n"
"   /*\n"
"    The origin of the ray.\n"
"   */\n"
"   float3 origin;\n"
"} Ray;\n"
"\n"
"/*\n"
"  Creates a ray with the given origin and direction.\n"
"  @param origin - The ray origin.\n"
"  @param dir - The ray direction.\n"
"  @return A ray with the given origin and direction.\n"
"*/\n"
"Ray make_ray(float3 origin, float3 dir) {\n"
"   Ray ray;\n"
"   ray.origin = origin;\n"
"   ray.dir = dir;\n"
"   return ray;\n"
"}\n"
"\n"
"/*\n"
"  Generates a uniformly-distributed random float in the interval [0, 1] based on\n"
"    the given random state. Updates the given random state.\n"
"  @param randState - A pointer to the random state.\n"
"  @return A random number in the interval [0, 1].\n"
"*/\n"
"float randUnit(uint *randState) {\n"
"   uint x = *randState;\n"
"   x ^= x << 13;\n"
"   x ^= x >> 17;\n"
"   x^= x << 5;\n"
"   *randState = x;\n"
"   return (float)(x) / 4294967296.0;\n"
"}\n"
"\n"
"/*\n"
"  Generates a uniformly-distributed random float in the interval [lo, hi] based\n"
"    on the given random state. Updates the given random state.\n"
"  @param lo - The lower bound of the random range.\n"
"  @param hi - The upper bound of the random range.\n"
"  @param randState - A pointer to the random state.\n"
"  @return A random number in the interval [lo, hi].\n"
"*/\n"
"float rand(float lo, float hi, uint *randState) {\n"
"   return (hi-lo)*randUnit(randState) + lo;\n"
"}\n"
"\n"
"/*\n"
"  A PBR material.\n"
"  It is packed so the structure matches the host material struct.\n"
"*/\n"
"typedef struct __attribute__ ((packed)) material {\n"
"  /*\n"
"    The probability the material will emit light.\n"
"  */\n"
"   float emissiveness;\n"
"   /*\n"
"     The color of the emitted light.\n"
"   */\n"
"   float3 emissionColor;\n"
"   /*\n"
"     The probability the material will reflect light like a metal.\n"
"     It is best to only use 0.0 or 1.0 for non-metals and metals, respectively.\n"
"   */\n"
"   float metalness;\n"
"   /*\n"
"     The base color of the material.\n"
"   */\n"
"   float3 baseColor;\n"
"} Material;\n"
"\n"
"/*\n"
"  A Ray-Triangle intersection.\n"
"*/\n"
"typedef struct intersection {\n"
"    /*\n"
"      Specifies the intersection position on the ray.\n"
"      intersectionPos = ray.origin + t*ray.dir;\n"
"    */\n"
"    float t;\n"
"    /*\n"
"      The position where the intersection occurred.\n"
"    */\n"
"    float3 pos;\n"
"    /*\n"
"      The interpolated texture coordinates of the surface at the intersection\n"
"      point.\n"
"    */\n"
"    float2 texCoord;\n"
"    /*\n"
"      The interpolated normal of the surface at the intersection point.\n"
"    */\n"
"    float3 normal;\n"
"    /*\n"
"      The index of the intersected triangle out of all triangles in the scene.\n"
"    */\n"
"    int triIndex;\n"
"    /*\n"
"      Whether there was an intersection or not.\n"
"    */\n"
"    bool intersects;\n"
"} Intersection;\n"
"\n"
"/*\n"
"  Returns the area of a triangle with vertices A,B,C.\n"
"  @param A - A vertex of the triangle.\n"
"  @param B - A vertex of the triangle.\n"
"  @param C - A vertex of the triangle.\n"
"  @return The triangle area.\n"
"*/\n"
"float triArea(float3 A, float3 B, float3 C) {\n"
"   return 0.5*length(cross(B-A, C-A));\n"
"}\n"
"\n"
"/*\n"
"  Calculates the intersection between a ray and a triangle if one exists.\n"
"    The triangle is specified by the vertices A,B,C.\n"
"  @param ray - The ray to used to check intersection.\n"
"  @param A - A vertex of the triangle.\n"
"  @param B - A vertex of the triangle.\n"
"  @param C - A vertex of the triangle.\n"
"  @param tcA - The texture coordinates of vertex A.\n"
"  @param tcB - The texture coordinates of vertex B.\n"
"  @param tcC - The texture coordinates of vertex C.\n"
"  @param nA - The normal of vertex A.\n"
"  @param nB - The normal of vertex B.\n"
"  @param nC - The normal of vertex C.\n"
"  @param triIndex - The index of the triangle out of all triangles in the scene.\n"
"  @return The intersection.\n"
"*/\n"
"Intersection rayTriangleIntersection(Ray ray, float3 A, float3 B, float3 C, float2 tcA, float2 tcB, float2 tcC, float3 nA, float3 nB, float3 nC, int triIndex) {\n"
"   Intersection notIntersection;\n"
"   notIntersection.t = 10000000000.0;\n"
"   notIntersection.pos = (float3)(0,0,0);\n"
"   notIntersection.normal = (float3)(0,0,0);\n"
"   notIntersection.triIndex = -1;\n"
"   notIntersection.intersects = false;\n"
"   float3 N = normalize(cross(A-B, A-C));\n"
"   float3 p = A;\n"
"    //Plane intersection\n"
"   float d = -dot(p, N);\n"
"   float denominator = dot(ray.dir, N);\n"
"   if (fabs(denominator) < 0.00001) return notIntersection;\n"
"   float t = -(dot(ray.origin, N) + d) / denominator;\n"
"   if (t < 0) return notIntersection;\n"
"    //Triangle intersection\n"
"   float3 pos = ray.origin + ray.dir*t;\n"
"   float fullTriArea = triArea(A,B,C);\n"
"   float aA = triArea(pos, B, C);\n"
"   float bA = triArea(pos, A, C);\n"
"   float cA = triArea(pos, A, B);\n"
"   float alpha = aA / fullTriArea;\n"
"   float beta = bA / fullTriArea;\n"
"   float gamma = cA / fullTriArea;\n"
"   if (fabs(fullTriArea - (aA+bA+cA)) < 0.0001 && fullTriArea > 0.0001) {\n"
"       Intersection in;\n"
"       in.t = t;\n"
"       in.pos = pos;\n"
"       in.texCoord = alpha*tcA + beta*tcB + gamma*tcC;\n"
"       in.normal = normalize(alpha*nA + beta*nB + gamma*nC);\n"
"       in.triIndex = triIndex;\n"
"       in.intersects = true;\n"
"       return in;\n"
"   }\n"
"   return notIntersection;\n"
"}\n"
"\n"
"/*\n"
"  Returns the intersection to the closest triangle along the ray. The closest\n"
"  triangle is defined as the intersection point being closest to the ray origin.\n"
"  @param ray - The ray used to check intersection.\n"
"  @param vertices - All vertices in the scene.\n"
"  @param texCoords - All texture coordinates in the scene.\n"
"  @param normals - All normals in the scene.\n"
"  @param triCount - The total number of triangles in the scene.\n"
"  @return The intersection.\n"
"*/\n"
"Intersection closestTriangle(Ray ray, global const float* vertices, global const float* texCoords, global const float* normals, const int triCount) {\n"
"   Intersection in;\n"
"   in.t = 10000000000.0;\n"
"   in.pos = (float3)(0,0,0);\n"
"   in.normal = (float3)(0,0,0);\n"
"   in.triIndex = -1;\n"
"   in.intersects = false;\n"
"   for (int i = 0; i < triCount; i++) {\n"
"       float3 A = (float3)(vertices[9*i + 0], vertices[9*i + 1], vertices[9*i + 2]);\n"
"       float3 B = (float3)(vertices[9*i + 3], vertices[9*i + 4], vertices[9*i + 5]);\n"
"       float3 C = (float3)(vertices[9*i + 6], vertices[9*i + 7], vertices[9*i + 8]);\n"
"       float2 tcA = (float2)(texCoords[6*i + 0], texCoords[6*i + 1]);\n"
"       float2 tcB = (float2)(texCoords[6*i + 2], texCoords[6*i + 3]);\n"
"       float2 tcC = (float2)(texCoords[6*i + 4], texCoords[6*i + 5]);\n"
"       float3 nA = (float3)(normals[9*i + 0], normals[9*i + 1], normals[9*i + 2]);\n"
"       float3 nB = (float3)(normals[9*i + 3], normals[9*i + 4], normals[9*i + 5]);\n"
"       float3 nC = (float3)(normals[9*i + 6], normals[9*i + 7], normals[9*i + 8]);\n"
"       Intersection triIn = rayTriangleIntersection(ray, A, B, C, tcA, tcB, tcC, nA, nB, nC, i);\n"
"       if (triIn.intersects && triIn.t < in.t) {\n"
"           in = triIn;\n"
"       }\n"
"   }\n"
"   return in;\n"
"}\n"
"\n"
"/*\n"
"  A light bounce or absorption.\n"
"*/\n"
"typedef struct bounce {\n"
"    /*\n"
"      Whether this bounce has an outgoing ray. There is an outgoing ray iff the\n"
"      light path was reflected.\n"
"    */\n"
"    bool hasOutRay;\n"
"    /*\n"
"      The outgoing ray. If hasOutRay is false, then this value is undefined and\n"
"      meaningless.\n"
"    */\n"
"    Ray outRay;\n"
"    /*\n"
"      The color factor of this bounce.\n"
"    */\n"
"    float3 color;\n"
"} Bounce;\n"
"\n"
"/*\n"
"  Computes one bounce of the given light path.\n"
"  @param ray - The ray representing the light path.\n"
"  @param randState - The state for the random number generator.\n"
"  @param vertices - All vertices in the scene.\n"
"  @param texCoords - All texture coordinates in the scene.\n"
"  @param normals - All normals in the scene.\n"
"  @param materials - All materials in the scene.\n"
"  @param triCount - The total number of triangles in the scene.\n"
"  @return The bounced or absorbed light data.\n"
"*/\n"
"Bounce renderPath(Ray ray, uint *randState, global const float* vertices, global const float* texCoords, global const float* normals, global const Material* materials, const int triCount) {\n"
"   Bounce b;\n"
"   Intersection in = closestTriangle(ray, vertices, texCoords, normals, triCount);\n"
"   if (!in.intersects) {\n"
"       b.hasOutRay = false;\n"
"       b.color = (float3)(0,0,0);\n"
"       return b; // Background\n"
"   }\n"
"   Material mat = materials[in.triIndex];\n"
"   if (rand(0,1,randState) < mat.emissiveness) {\n"
"       b.hasOutRay = false;\n"
"       b.color = 5.0f*mat.emissionColor;\n"
"       return b; // Emitter\n"
"   }\n"
"   if (rand(0,1,randState) < 0.25) {\n"
"       b.hasOutRay = false;\n"
"       b.color = (float3)(0,0,0);\n"
"       return b; // Absorbed\n"
"   }\n"
"   if (rand(0,1,randState) < mat.metalness) {\n"
"       b.hasOutRay = true;\n"
"       b.outRay = make_ray(in.pos, reflect(ray.dir, in.normal));\n"
"       b.color = mat.baseColor;\n"
"       return b;\n"
"   }\n"
"   float3 N = in.normal;\n"
"   float theta = rand(0, 2*PI, randState);\n"
"   float phi = rand(0, 2*PI, randState);\n"
"   float3 s = (float3)(1.0, theta, phi); // Random point on sphere\n"
"   float3 pathDir = (float3)(s.x*sin(s.z)*cos(s.y),\n"
"                             s.x*sin(s.z)*sin(s.y),\n"
"                             s.x*cos(s.z));\n"
"   pathDir = pathDir + N;\n"
"   pathDir = normalize(pathDir);\n"
"   float lambertReflectanceFactor = dot(N, pathDir);\n"
"   Ray reflectedRay = make_ray(in.pos + 0.000001f*N, pathDir);\n"
"   float3 colorScale = lambertReflectanceFactor*mat.baseColor;\n"
"   b.hasOutRay = true;\n"
"   b.outRay = reflectedRay;\n"
"   b.color = colorScale;\n"
"   return b;\n"
"}\n"
"\n"
"/*\n"
"  Renders one light path through a pixel.\n"
"  @param vertices - All vertices in the scene.\n"
"  @param texCoords - All texture coordinates in the scene.\n"
"  @param normals - All normals in the scene.\n"
"  @param materials - All materials in the scene (one material per triangle).\n"
"  @param triCount - The total number of triangles in the scene.\n"
"  @param width - The width of the rendered viewport in pixels.\n"
"  @param height - The height of the rendered viewport in pixels.\n"
"  @param samplesPerPixel - The number of samples per pixel.\n"
"  @param outPixels - The rendered pixel data.\n"
"  @param randStates - The random states for each pixel in the scene.\n"
"*/\n"
"void kernel render(global const float* vertices, global const float* texCoords, global const float* normals, global const Material* materials, const int triCount, const int width, const int height, const int samplesPerPixel, global float* outPixels, global uint* randStates){\n"
"   int x = get_global_id(0);\n"
"   int y = get_global_id(1);\n"
"   uint randState = randStates[y*width + x];\n"
"   float2 uvOffset = (float2)(rand(0,1,&randState), rand(0,1,&randState)) / (float)(height);\n"
"   float2 uv = uvOffset + (float2)(x - width/2.0, y - height/2.0) / (float)(height);\n"
"   float3 camera = (float3)(0, 0, -2);\n"
"   float3 rayDir = normalize((float3)(uv.x, uv.y, 0) - camera);\n"
"   Ray ray = make_ray(camera, rayDir);\n"
"   float3 color = (float3)(1,1,1);\n"
"   Bounce b = renderPath(ray, &randState, vertices, texCoords, normals, materials, triCount);\n"
"   color *= b.color;\n"
"   while (b.hasOutRay) {\n"
"       ray = b.outRay;\n"
"       b = renderPath(ray, &randState, vertices, texCoords, normals, materials, triCount);\n"
"       color *= b.color;\n"
"   }\n"
"   color /= samplesPerPixel;\n"
"   int pixelIndex = 3*(y*width + x);\n"
"   outPixels[pixelIndex+0] += color.x;\n"
"   outPixels[pixelIndex+1] += color.y;\n"
"   outPixels[pixelIndex+2] += color.z;\n"
"   randStates[y*width + x] = randState;\n"
"}                                                                               ;\n"
"\n";
#endif
